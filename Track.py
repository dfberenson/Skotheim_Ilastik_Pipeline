# -*- coding: utf-8 -*-
"""
Created on Mon Dec 04 18:52:38 2017

@author: dfberenson
"""

import numpy as np
import pandas as pd
from TrackPoint import TrackPoint

class Track(object):
    
    def __init__(self, expt, df, trackId, init_frame):
        '''
        Create a new Track object from the information in the passed DataFrame,
        for the track with the passed trackId and starting at the passed init_frame.
        Do this by creating a new TrackPoint at the init_frame, then propagating it forward.
        If a daughter cell is encountered as a result of this propagation, it will have proper links to/from its mother.
        However, if a daughter cell's Track is created de novo (as it will be when that TrackId is reached iterating through expt.trackIds_list,
        it will not be linked to/from its mother and will exist independently of the matching mother-propagated traack.
        That is, Track 1 will link to/from Track 1A and Track 1B, and then there will also be independent, unlinked Track 1A and Track 1B.
        ToDo: Make each daughter Track exist only once.)
        ''' 
        self.expt = expt
        self.df = df
        self.trackId = trackId  
        self.init_frame = init_frame
        
        self.init_trackpoint = TrackPoint(self, self.init_frame, None)
        print('\n')
        self.init_trackpoint.propagate_trackpoint()
        self.getLifespan()
        
    def getLifespan(self):
        '''
        Returns an int representing the lifespan in frames of this Track.
        Also stores it as self.lifespan and stores the information self.last_frame and self.last_trackpoint.
        If this method is not called, the Track will not immediately know where its last trackpoint is.
        Counts lifespan only as linear progression; a division event ends the lifespan.
        '''
        curr_trackpoint = self.init_trackpoint
        while curr_trackpoint.next_trackpoint is not None:
            curr_trackpoint = curr_trackpoint.next_trackpoint
        self.last_trackpoint = curr_trackpoint
        self.last_frame = self.last_trackpoint.frame
        self.lifespan = self.last_frame - self.init_frame
        return self.lifespan


    def toDataFrame(self, measurements_list = ['Lineage','Lifespan','Mother','DaughterA','DaughterB','CentroidX','CentroidY',
        'Area','MeanIntensity_Chan1','IntegratedIntensity_Chan1','MeanLocalBackground_Chan1','NetIntegratedIntensity_Chan1',
        'MeanIntensity_Chan2','IntegratedIntensity_Chan2','MeanLocalBackground_Chan2','NetIntegratedIntensity_Chan2']):
        '''
        Returns a small DataFrame, structured as elsewhere, generated by following the Track through to its end.
        Stops at division events so this method needs to be called on all daughter cells as well if a complete DataFrame is to be assembled.   
        '''
        
        self.getLifespan()
        idx = np.arange(self.init_frame, self.last_frame + 1)
        new_df = pd.DataFrame(index = idx, columns = pd.MultiIndex.from_product([[self.trackId],measurements_list],
                                                    names = ['cell number','measurement']))
        new_df.index.name = 'frame'
        new_df.sort_index(axis = 'columns', inplace = True)
        
        curr_trackpoint = self.init_trackpoint
        while curr_trackpoint is not None:
            frame = curr_trackpoint.frame
            new_df.loc[frame,(self.trackId,'Mother')] = np.float64(curr_trackpoint.Mother)
            new_df.loc[frame,(self.trackId,'DaughterA')] = np.float64(curr_trackpoint.DaughterA)
            new_df.loc[frame,(self.trackId,'DaughterB')] = np.float64(curr_trackpoint.DaughterB)
            new_df.loc[frame,(self.trackId,'Lineage')] = np.float64(curr_trackpoint.Lineage)
            new_df.loc[frame,(self.trackId,'CentroidX')] = np.float64(curr_trackpoint.CentroidX)
            new_df.loc[frame,(self.trackId,'CentroidY')] = np.float64(curr_trackpoint.CentroidY)
            new_df.loc[frame,(self.trackId,'Area')] = np.float64(curr_trackpoint.Area)
            new_df.loc[frame,(self.trackId,'MeanIntensity_Chan1')] = np.float64(curr_trackpoint.MeanIntensity_Chan1)
            new_df.loc[frame,(self.trackId,'MeanIntensity_Chan2')] = np.float64(curr_trackpoint.MeanIntensity_Chan2)
            new_df.loc[frame,(self.trackId,'IntegratedIntensity_Chan1')] = np.float64(curr_trackpoint.IntegratedIntensity_Chan1)
            new_df.loc[frame,(self.trackId,'IntegratedIntensity_Chan2')] = np.float64(curr_trackpoint.IntegratedIntensity_Chan2)
            curr_trackpoint = curr_trackpoint.next_trackpoint
        
        return new_df
    
    def getImStack_and_TrackPointStack(self, frames_to_skip, stack_length):
        '''
        Starting after frames_to_skip, return an image stack and a list of TrackPoints with length 'stack_length'.
        Does not work with branched (dividing) tracks.
        ToDo: image should be recolored to highlight the tracked objects.
        '''
        stack_first_trackpoint = self.init_trackpoint
        
        for i in range(frames_to_skip):
            stack_first_trackpoint = stack_first_trackpoint.next_trackpoint
            assert stack_first_trackpoint is not None
            #Travel through Track until have skipped the appropriate number of frames, then assert we're at a real TrackPoint.
        
        centX = stack_first_trackpoint.CentroidX
        centY = stack_first_trackpoint.CentroidY
        first_img = stack_first_trackpoint.getImage(centX = centX, centY = centY)
        this_trackpoint = stack_first_trackpoint
        im_stack = np.array([first_img] * stack_length) #Initialize image stack of right size.
        trackpoint_stack = [None] * stack_length #Initialize trackpoint stack of right size.
                           
        for i in range(stack_length):
            assert this_trackpoint is not None
            trackpoint_stack[i] = this_trackpoint
            this_img = this_trackpoint.getImage(centX = centX, centY = centY)
            im_stack[i] = this_img
            this_trackpoint = this_trackpoint.next_trackpoint
        
        return (im_stack,trackpoint_stack)
            
    
    def visualizeStructure(self):
        '''
        ToDo: maybe can do something here to show all the TrackPoints the Track goes through?
        Could be something like MaMuT's Track Viewer.
        '''
        pass
    
    
    def __str__(self):
        return '<<Track object with trackId {} starting at frame {} ending at frame {}.>>'.format(self.trackId, self.init_frame, self.last_frame)
    
    __repr__ = __str__
        #Ensures the __str__ output is used whether or not the print() method is explicitly called.